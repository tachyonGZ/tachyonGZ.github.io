<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>tachyonGZΣ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="tachyonGZΣ">
<meta property="og:url" content="https://tachyongz.github.io/index.html">
<meta property="og:site_name" content="tachyonGZΣ">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="tachyonGZΣ" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">tachyonGZΣ</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://tachyongz.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-如何在steam上入库锁国区的游戏" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/06/%E5%A6%82%E4%BD%95%E5%9C%A8steam%E4%B8%8A%E5%85%A5%E5%BA%93%E9%94%81%E5%9B%BD%E5%8C%BA%E7%9A%84%E6%B8%B8%E6%88%8F/" class="article-date">
  <time class="dt-published" datetime="2025-07-06T14:52:07.000Z" itemprop="datePublished">2025-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/06/%E5%A6%82%E4%BD%95%E5%9C%A8steam%E4%B8%8A%E5%85%A5%E5%BA%93%E9%94%81%E5%9B%BD%E5%8C%BA%E7%9A%84%E6%B8%B8%E6%88%8F/">如何在steam上入库锁国区的游戏</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>大体可以分为三个步骤：</p>
<ol>
<li>首先在国区下单一款游戏</li>
<li>我们使用加速器或梯子切换到外区，并更改付款时使用结算货币</li>
<li>我们在下单另一款游戏，在这一步使用外区货币结算这两款游戏<br>虽然我们在转区过程中付款了两款游戏，但是我们后续可以将这两款我们不想要的游戏退款。</li>
</ol>
<h2 id="在国区下单一款游戏"><a href="#在国区下单一款游戏" class="headerlink" title="在国区下单一款游戏"></a>在国区下单一款游戏</h2><p>在国区下单任意一款低价游戏，进入到付款页面，选择支付宝或微信两者当中的任意一款支付方式，笔者这里选择支付宝作为演示。</p>
<p>当我们进入到二维码付款界面的时候注意不要扫码付款，直接右上角关掉付款界面返回。</p>
<p>紧接着进入到第二个步骤。</p>
<h2 id="使用加速器或梯子切换到外区，并更改付款货币"><a href="#使用加速器或梯子切换到外区，并更改付款货币" class="headerlink" title="使用加速器或梯子切换到外区，并更改付款货币"></a>使用加速器或梯子切换到外区，并更改付款货币</h2><p>打开加速器或者梯子，代理到国外ip。<br>成功后返回steam界面，切换付款时候使用的货币。</p>
<p>上述步骤完成后进入第三个步骤。</p>
<h2 id="再次下单任意一款游戏"><a href="#再次下单任意一款游戏" class="headerlink" title="再次下单任意一款游戏"></a>再次下单任意一款游戏</h2><p>我们再次在商店中选择任意一款低价游戏，进入到付款页面，此时会发现购物车中有你之前第一步中下单的那款游戏。<br>我们在这里需要付款，但是需要注意，要选择与第一步中不同的付款方式，例如笔者在第一步中演示的是支付宝支付，那么我们应当在这一步中选择微信支付。</p>
<p>到此为止我们已经完成了转区的所有步骤，是不是很简单？<br>现在你可以入库你心仪的外区游戏了。</p>
<h2 id="关于退款"><a href="#关于退款" class="headerlink" title="关于退款"></a>关于退款</h2><p>关于如何退款，如果不了解的话，可以看笔者的另一篇文章。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tachyongz.github.io/2025/07/06/%E5%A6%82%E4%BD%95%E5%9C%A8steam%E4%B8%8A%E5%85%A5%E5%BA%93%E9%94%81%E5%9B%BD%E5%8C%BA%E7%9A%84%E6%B8%B8%E6%88%8F/" data-id="cmcrss9sc0000ogv307z6gjm2" data-title="如何在steam上入库锁国区的游戏" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Steam/" rel="tag">Steam</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-更改VSCode插件的默认安装路径" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/10/%E6%9B%B4%E6%94%B9VSCode%E6%8F%92%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/" class="article-date">
  <time class="dt-published" datetime="2025-05-09T17:18:14.000Z" itemprop="datePublished">2025-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/">软件配置</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/05/10/%E6%9B%B4%E6%94%B9VSCode%E6%8F%92%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/">更改VSCode插件的默认安装路径</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>关于vscode如何更改插件的加载路径，网络上有许多相关的文章，但无非就是两种：</p>
<ol>
<li>在原本的插件存放路径创建一个链接，指向新的存放路径。</li>
<li>通过为vscode添加启动项的方式，<code>--extensions-dir &lt;dir&gt;</code>，其中<code>dir</code>参数填入新的存放路径。</li>
</ol>
<p>那么有没有更加优雅的方式来修改插件的加载路径，笔者经过浏览vscode的文档，找到了相关的资料:</p>
<blockquote>
<p>Alternatively, you can set the <code>VSCODE_EXTENSIONS</code> environment variable to a location where you want to install extensions. This is useful in an enterprise environment where you want to centrally manage where extensions are installed on user machines.<br>Whenever I try to install any ext</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/configure/extensions/extension-marketplace#_common-questions">原文链接</a></p>
<p>vscode提供了一种方式，通过声明定义环境变量<code>VSCODE_EXTENSIONS</code>，并将插件路径赋值给这个变量，能让vscode在启动的时候加载这个路径下的插件。<br>举个例子，vscode的默认插件存放路径是<code>%USERPROFILE%\.vscode\extensions</code>，等价于<code>VSCODE_EXTENSIONS=%USERPROFILE%\.vscode\extensions</code></p>
<p>寻找问题的答案时，不要太过执着于网上的文章，多去浏览一些软件的官方文档，有时候会有意想不到的收获……</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tachyongz.github.io/2025/05/10/%E6%9B%B4%E6%94%B9VSCode%E6%8F%92%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/" data-id="cmah35i820000xwv32au7cfo9" data-title="更改VSCode插件的默认安装路径" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-缓存的设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/18/%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2025-03-18T14:20:40.000Z" itemprop="datePublished">2025-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/18/%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">缓存的设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>利用缓存来加速系统已经成为很常见的一种操作。这种方式有效率、简单，而且成本也在可控的范围内。</p>
<p>说到缓存，通常会下意识的想到缓存是用来加速读的，实际上，读数据和写数据都可以使用缓存。</p>
<p>这些缓存模式并不是新技术，而是伴随在计算机体系结构演进中。</p>
<h1 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache-Aside"></a>Cache-Aside</h1><p>如果从缓存中找到数据，称之为命中缓存,如果没有找到数据，称为之未命中缓存。</p>
<p>Cache-Aside 应该是使用最为广泛的一种模式。应用直接去缓存中找数据，命中缓存则直接返回，如果未命中缓存，则需要先去数据库中查询数据，并将查询到的数据存储到缓存中。</p>
<p>这种方式会让缓存中的数据与数据库中的数据不一致，所以一般会给缓存中的数据设置过期时间（TTL），数据过期之后就去数据库中取最新的数据。</p>
<ul>
<li>适用场景：读多写少。</li>
<li>缺点：多线程下易出现数据不一致的问题。</li>
</ul>
<h1 id="Read-Through-Write-Through"><a href="#Read-Through-Write-Through" class="headerlink" title="Read-Through &amp; Write-Through"></a>Read-Through &amp; Write-Through</h1><p>Read-Through的过程是查询缓存是否存在，存在则返回；不存在则由缓存组件去数据库加载数据。</p>
<p>Read-Through 的方式与 Cache-Aside 的方式很接近，区别在于，Cache-Aside 是通过应用程序来更新缓存中的数据，<br>而 Read-Through 则是通过缓存自身来更新数据，也就是说应用和数据库之间不直接进行连接。</p>
<p>Write-Through的过程是先查询要写入的数据在缓存是否存在，存在则先更新缓存然后再更新数据库最后返回；如果要写入的数据在缓存不存在，有两对应策略：一种是先将数据写入缓存，然后由缓存组件将数据同步更新到数据库；另一种策略是不写缓存直接将数据写入数据库。</p>
<p>Write-Through 会先将数据写入到缓存中，然后由缓存将数据存入到数据库中。</p>
<p>Write-Through 与 Read-Through 相结合可以很好的解决缓存和数据库中数据不一致的问题，Write-Through 每次都会先更新缓存中的数据，所以每次读到的数据也是最新的。</p>
<ul>
<li>适用场景：读多写少。</li>
<li>缺点：<ol>
<li>因为应用操作数据时只与缓存组件交互，相对于Cache-Aside而言数据不一致的概率要低一些。</li>
<li>因为此模式下缓存没有过期时间，所以缓存的使用量会非常大。</li>
</ol>
</li>
</ul>
<h1 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write-Back"></a>Write-Back</h1><p>Write-Back是承接Write-Through的，在对数据进行数据持久化存储回写时一般采用异步回写，也可以间隔一定时间后批量回写</p>
<p>Write-Through 每写一次缓存，缓存就会写一次数据库，而 Write-Back 则是写了多次缓存后才会写一次数据库，可以大大减轻服务器的压力。</p>
<ul>
<li>适用场景：读少写多</li>
<li>缺点：<ol>
<li>异步或间隔一定时间的批量回写会导致数据延迟</li>
<li>在数据回写前缓存出现问题，即这部分数据没有持久化，可能会导致数据丢失。</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tachyongz.github.io/2025/03/18/%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="cm8elm8l7000018v32kicawhh" data-title="缓存的设计模式" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-深入解析-Go-语言-GMP-模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/15/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Go-%E8%AF%AD%E8%A8%80-GMP-%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2025-03-15T13:00:59.000Z" itemprop="datePublished">2025-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/15/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Go-%E8%AF%AD%E8%A8%80-GMP-%E6%A8%A1%E5%9E%8B/">深入解析 Go 语言 GMP 模型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h1><p>在深入了解Goroutine之前，先来了解一下协程（Coroutine）的基本概念。</p>
<h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><ul>
<li><strong>内核态线程</strong>：由操作系统管理和调度，CPU只负责处理内核态线程。</li>
<li><strong>用户态线程</strong>：由用户程序管理，需绑定到内核态线程上执行，协程即为用户态线程的一种。</li>
</ul>
<h2 id="内核态和用户态线程关系图"><a href="#内核态和用户态线程关系图" class="headerlink" title="内核态和用户态线程关系图"></a>内核态和用户态线程关系图</h2><p><img src="/2025/02/19/%E6%81%90%E6%83%A7%E4%B8%8E%E8%B4%AA%E5%A9%AA%E6%8C%87%E6%95%B0/%E8%AF%AD%E8%A8%80-GMP-%E6%A8%A1%E5%9E%8B/1.webp"></p>
<ul>
<li><strong>Kernel Space（内核空间）</strong>：上半部分的灰色区域，表示操作系统管理的内核空间。</li>
<li><strong>User Space（用户空间）</strong>：下半部分的白色区域，表示用户程序运行的空间。</li>
<li><strong>Kernel Thread 1 和Kernel Thread 2（内核线程）</strong>：由操作系统管理的内核线程，CPU直接处理这些线程。</li>
<li><strong>User Thread 1、User Thread 2 和 User Thread 3（用户线程）</strong>：由用户程序管理的用户线程（协程），需绑定到内核线程上执行。</li>
</ul>
<h2 id="线程和协程的映射关系"><a href="#线程和协程的映射关系" class="headerlink" title="线程和协程的映射关系"></a>线程和协程的映射关系</h2><p><img src="/2025/02/19/%E6%81%90%E6%83%A7%E4%B8%8E%E8%B4%AA%E5%A9%AA%E6%8C%87%E6%95%B0/%E8%AF%AD%E8%A8%80-GMP-%E6%A8%A1%E5%9E%8B/2.webp"></p>
<ol>
<li><strong>单线程绑定所有协程</strong>：<ul>
<li><strong>问题1</strong>：无法利用多核CPU的能力。</li>
<li><strong>问题2</strong>：如果某个协程阻塞，整个线程和进程都将阻塞，导致其他协程无法执行，丧失并发能力。</li>
</ul>
</li>
<li><strong>一对一映射</strong>：<ul>
<li>将每个协程绑定到一个线程上，退回到多进程&#x2F;线程的模式，协程的创建、切换、销毁均需CPU完成，效率低下。</li>
</ul>
</li>
<li><strong>多对多映射</strong>：<ul>
<li>允许多个协程绑定到多个线程上，形成M:N的关系。这样可以充分利用多核CPU，并通过协程调度器高效管理协程的执行。</li>
</ul>
</li>
</ol>
<h1 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h1><p>Goroutine是Go语言中的协程，实现了轻量级并发。与传统的线程相比，Goroutine具有以下显著特点：</p>
<h2 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h2><p>Goroutine非常轻量，初始化时仅占用几KB的栈内存，并且栈内存可以根据需要动态伸缩。<br>这使得我们可以在Go程序中创建成千上万个Goroutine，而不会消耗过多的系统资源。</p>
<h2 id="高效调度"><a href="#高效调度" class="headerlink" title="高效调度"></a>高效调度</h2><p>Goroutine的调度由Go语言的运行时（runtime）负责，而不是操作系统。<br>Go运行时在用户态进行调度，避免了频繁的上下文切换带来的开销，使得调度更加高效。</p>
<h1 id="Goroutine的使用示例"><a href="#Goroutine的使用示例" class="headerlink" title="Goroutine的使用示例"></a>Goroutine的使用示例</h1><h1 id="Goroutine调度器"><a href="#Goroutine调度器" class="headerlink" title="Goroutine调度器"></a>Goroutine调度器</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在Go中，线程是运行Goroutine的实体，而调度器的功能是将可运行的Goroutine分配到工作线程上。Go语言采用了一种高效的Goroutine调度机制，使得程序能够在多核处理器上高效运行。</p>
<h2 id="被废弃的调度器"><a href="#被废弃的调度器" class="headerlink" title="被废弃的调度器"></a>被废弃的调度器</h2><p>早期的调度器采用了简单的设计，存在多个缺陷：</p>
<ul>
<li><strong>概念</strong>：用大写的G表示协程，用大写的M表示线程。</li>
<li><strong>问题</strong>：<ul>
<li><strong>锁竞争</strong>：每个M（线程）想要执行、放回G（协程）都必须访问一个全局G队列，因此对G的访问需要加锁以保证并发安全。当有很多线程时，锁竞争激烈，影响系统性能。</li>
<li><strong>局部性破坏</strong>：M转移G会造成延迟和额外的系统负载。例如，当一个G内创建另一个G’时，为了继续执行G，需要将G’交给另一个M’执行，这会破坏程序的局部性。</li>
<li><strong>系统开销</strong>：CPU在线程之间频繁切换导致频繁的系统调用，增加了系统开销。</li>
</ul>
</li>
</ul>
<h2 id="GMP模型的设计思想"><a href="#GMP模型的设计思想" class="headerlink" title="GMP模型的设计思想"></a>GMP模型的设计思想</h2><p>为了克服上述问题，Go引入了GMP模型：<br><img src="/2025/02/19/%E6%81%90%E6%83%A7%E4%B8%8E%E8%B4%AA%E5%A9%AA%E6%8C%87%E6%95%B0/%E8%AF%AD%E8%A8%80-GMP-%E6%A8%A1%E5%9E%8B/3.webp"></p>
<h3 id="G（Goroutine）"><a href="#G（Goroutine）" class="headerlink" title="G（Goroutine）"></a>G（Goroutine）</h3><p>Goroutine是Go语言中的协程，代表一个独立的执行单元。Goroutine比线程更加轻量级，启动一个Goroutine的开销非常小。Goroutine的调度由Go运行时在用户态进行。</p>
<h3 id="M（Machine）"><a href="#M（Machine）" class="headerlink" title="M（Machine）"></a>M（Machine）</h3><p>M代表操作系统的线程。M负责实际执行Go代码。一个M可以执行多个Goroutine，但同一时间只能执行一个Goroutine。M与操作系统的线程直接对应，Go运行时通过M来利用多核CPU的并行计算能力。</p>
<h3 id="P（Processor）"><a href="#P（Processor）" class="headerlink" title="P（Processor）"></a>P（Processor）</h3><p>P代表执行上下文（Processor）。P管理着可运行的Goroutine队列，并负责与M进行绑定。P的数量决定了可以并行执行的Goroutine的数量。Go运行时会根据系统的CPU核数设置P的数量。</p>
<ul>
<li><p>基本概念：</p>
<ul>
<li>Go语言使用GMP模型来管理并发执行。GMP模型由三个核心组件组成：G（Goroutine）、M（Machine）、P（Processor）</li>
</ul>
</li>
<li><p>GMP模型的组成：</p>
<ul>
<li>全局G队列：存放等待运行的G。</li>
<li>P的本地G队列：存放不超过256个G。当新建协程时优先将G存放到本地队列，本地队列满了后将一半的G移动到全局队列。</li>
<li>M：内核态线程，线程想要运行协程需要先获取一个P，从P的本地G队列中获取G。当本地队列为空时，会尝试从全局队列或其他P的本地G列表中偷取G。</li>
<li>P列表：程序启动时创建GOMAXPROCS个P，并保存在数组中。</li>
</ul>
</li>
<li><p>调度器与OS调度器结合：</p>
<ul>
<li>Go的Goroutine调度器与操作系统调度器结合，OS调度器负责将线程分配给CPU执行。</li>
</ul>
</li>
</ul>
<h2 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h2><h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><h2 id="GMP模型的优势"><a href="#GMP模型的优势" class="headerlink" title="GMP模型的优势"></a>GMP模型的优势</h2><ol>
<li><strong>高效的资源利用</strong>：通过在用户态进行调度，避免了频繁的上下文切换带来的开销，充分利用CPU资源。</li>
<li><strong>轻量级并发</strong>：Goroutine比线程更加轻量级，可以启动大量的Goroutine而不会消耗大量内存。</li>
<li><strong>自动调度</strong>：Go运行时自动管理Goroutine的调度，无需程序员手动干预，简化了并发编程的复杂度。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tachyongz.github.io/2025/03/15/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Go-%E8%AF%AD%E8%A8%80-GMP-%E6%A8%A1%E5%9E%8B/" data-id="cm8a88l2o00005gv3gr3z0dwe" data-title="深入解析 Go 语言 GMP 模型" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go中的context详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/20/Go%E4%B8%AD%E7%9A%84context%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2025-02-19T16:00:00.000Z" itemprop="datePublished">2025-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/20/Go%E4%B8%AD%E7%9A%84context%E8%AF%A6%E8%A7%A3/">Go中的context详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="context包的起源与作用"><a href="#context包的起源与作用" class="headerlink" title="context包的起源与作用"></a><code>context</code>包的起源与作用</h2><p><code>context</code>可以用来在<code>goroutine</code>之间传递上下文信息，相同的<code>context</code>可以传递给运行在不同<code>goroutine</code>中的函数，上下文对于多个<code>goroutine</code>同时使用是安全的，<code>context</code>包定义了上下文类型，可以使用<code>background</code>、<code>TODO</code>创建一个上下文，在函数调用链之间传播<code>context</code>，也可以使用<code>WithDeadline</code>、<code>WithTimeout</code>、<code>WithCancel</code> 或 <code>WithValue</code> 创建的修改副本替换它，听起来有点绕，其实总结起就是一句话：<code>context</code>的作用就是在不同的<code>goroutine</code>之间同步请求特定的数据、取消信号以及处理请求的截止日期。</p>
<p>目前我们常用的一些库都是支持<code>context</code>的，例如<code>gin</code>、<code>database/sql</code>等库都是支持<code>context</code>的，这样更方便我们做并发控制了，只要在服务器入口创建一个<code>context</code>上下文，不断透传下去即可。</p>
<h2 id="context的使用"><a href="#context的使用" class="headerlink" title="context的使用"></a><code>context</code>的使用</h2><h3 id="创建context"><a href="#创建context" class="headerlink" title="创建context"></a>创建<code>context</code></h3><p><code>context</code>包主要提供了两种方式创建<code>context</code>:</p>
<ul>
<li><code>context.Backgroud()</code></li>
<li><code>context.TODO()</code></li>
</ul>
<p>这两个函数其实只是互为别名，没有差别，官方给的定义是：</p>
<ul>
<li><code>context.Background</code> 是上下文的默认值，所有其他的上下文都应该从它衍生（Derived）出来。</li>
<li><code>context.TODO</code> 应该只在不确定应该使用哪种上下文时使用；</li>
</ul>
<p>所以在大多数情况下，我们都使用<code>context.Background</code>作为起始的上下文向下传递。</p>
<p>上面的两种方式是创建根<code>context</code>，不具备任何功能，具体实践还是要依靠<code>context</code>包提供的<code>With</code>系列函数来进行派生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context</span><br></pre></td></tr></table></figure>

<p>这四个函数都要基于父<code>Context</code>衍生，通过这些函数，就创建了一颗<code>Context</code>树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个，画个图表示一下：</p>
<p><img src="/2025/02/19/%E6%81%90%E6%83%A7%E4%B8%8E%E8%B4%AA%E5%A9%AA%E6%8C%87%E6%95%B0/ext%E8%AF%A6%E8%A7%A3/1.webp"></p>
<p>基于一个父<code>Context</code>可以随意衍生，其实这就是一个<code>Context</code>树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个，每个子节点都依赖于其父节点，例如上图，我们可以基于<code>Context.Background</code>衍生出四个子<code>context</code>：<code>ctx1.0-cancel</code>、<code>ctx2.0-deadline</code>、<code>ctx3.0-timeout</code>、<code>ctx4.0-withvalue</code>，这四个子<code>context</code>还可以作为父<code>context</code>继续向下衍生，即使其中<code>ctx1.0-cancel</code> 节点取消了，也不影响其他三个父节点分支。</p>
<p>创建<code>context</code>方法和<code>context</code>的衍生方法就这些，下面我们就一个一个来看一下他们如何被使用。</p>
<h3 id="WithValue携带数据"><a href="#WithValue携带数据" class="headerlink" title="WithValue携带数据"></a><code>WithValue</code>携带数据</h3><p>我们日常在业务开发中都希望能有一个<code>trace_id</code>能串联所有的日志，这就需要我们打印日志时能够获取到这个<code>trace_id</code>，通过使用<code>WithValue</code>来创建一个携带<code>trace_id</code>的<code>context</code>，然后不断透传下去，打印日志时输出即可，来看使用例子：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tachyongz.github.io/2025/02/20/Go%E4%B8%AD%E7%9A%84context%E8%AF%A6%E8%A7%A3/" data-id="cm7d85yre00006gv35kge68c0" data-title="Go中的context详解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-恐惧与贪婪指数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/19/%E6%81%90%E6%83%A7%E4%B8%8E%E8%B4%AA%E5%A9%AA%E6%8C%87%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2025-02-18T16:00:00.000Z" itemprop="datePublished">2025-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/19/%E6%81%90%E6%83%A7%E4%B8%8E%E8%B4%AA%E5%A9%AA%E6%8C%87%E6%95%B0/">恐惧与贪婪指数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="什么是恐惧与贪婪指数？"><a href="#什么是恐惧与贪婪指数？" class="headerlink" title="什么是恐惧与贪婪指数？"></a>什么是恐惧与贪婪指数？</h1><p>加密货币市场的行为是非常情绪化的。当市场上涨时，人们趋于贪婪，产生害怕错过的情绪；当市场下跌时，却会以不理智的反应出售他们的加密货币。</p>
<p>借助恐惧和贪婪指数，尽可能使您摆脱自身的情感因素。</p>
<h1 id="恐惧与贪婪指数有何意义？"><a href="#恐惧与贪婪指数有何意义？" class="headerlink" title="恐惧与贪婪指数有何意义？"></a>恐惧与贪婪指数有何意义？</h1><p>极度恐惧表明投资者过于担心，可能是一个买入机会。<br>过于贪婪表明投资者过于兴奋，市场可能会进行调整。</p>
<p>因此，恐惧与贪婪指数分析了比特币市场的当前情绪，并将其用0到100予以表示。</p>
<p>注意，CoinGlass上提供的的恐惧与贪婪指数仅适用于比特币。</p>
<h1 id="CoinGlass上的恐惧与贪婪指数具体组成"><a href="#CoinGlass上的恐惧与贪婪指数具体组成" class="headerlink" title="CoinGlass上的恐惧与贪婪指数具体组成"></a>CoinGlass上的恐惧与贪婪指数具体组成</h1><ul>
<li><p>波动率（25％）<br>获取比特币当前的波动率和最大值，并将其与最近30天和90天的相应平均值进行比较。我们认为，波动率的异常上升是市场恐惧的迹象。</p>
</li>
<li><p>市场动量&#x2F;交易量（25％）<br>当前的交易量和市场动能（与最近30&#x2F;90天的平均值进行比较），并将这两个值放在一起。通常，当我们每天在积极市场中看到大量购买量时，可以得出结论，市场表现得过于贪婪&#x2F;过于看涨。</p>
</li>
<li><p>社交媒体（15％）<br>收集并计算reddit及twitter每种硬币在各种标签上的帖子（公开地，我们仅显示比特币的帖子），并检查它们在特定时间范围内的接收速度和交互次数。异常高的交互速度表明公众的兴趣与日俱增，这与贪婪的市场行为相对应。</p>
</li>
<li><p>市场调查（15％）<br>每周在投票平台strawpoll.com上进行一次加密货币民意测验，并询问人们他们如何看待市场。通常，每次民意调查都会得到2000-3000个答卷，因此我们确实可以看到一组加密货币投资者的情绪。我们对这些结果并没有给予过多的关注，但是在我们的研究开始之时它是非常有用的。</p>
</li>
<li><p>主导地位（10％）<br>主导地位类似于整个加密货币市场的市值份额。特别是对于比特币，我们认为比特币主导地位的上升是由于对过于投机性的另类货币投资的恐惧，因为比特币正越来越成为加密货币的避风港。另一方面，当比特币的主导地位下降时，人们变得更加贪婪，他们投资于风险更大的其它货币，梦想着在下一次大牛市中获得机会。无论如何，分析一种非比特币货币的主导地位，你可能会得出相反的结论，因为对另一种货币更感兴趣，可能会得出该货币看涨&#x2F;贪婪行为的结论。</p>
</li>
<li><p>Google趋势（10％）<br>提取各种与比特币相关的搜索关键字的Google趋势数据，并对这些数字进行处理，尤其是搜索量的变化以及推荐的其他当前流行的搜索，将其用于指数。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tachyongz.github.io/2025/02/19/%E6%81%90%E6%83%A7%E4%B8%8E%E8%B4%AA%E5%A9%AA%E6%8C%87%E6%95%B0/" data-id="cm7bdcfgv0000icv3b0hkeu00" data-title="恐惧与贪婪指数" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-一文读懂黄金价格与美元汇率的关系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/19/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E9%BB%84%E9%87%91%E4%BB%B7%E6%A0%BC%E4%B8%8E%E7%BE%8E%E5%85%83%E6%B1%87%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2025-02-18T16:00:00.000Z" itemprop="datePublished">2025-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/19/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E9%BB%84%E9%87%91%E4%BB%B7%E6%A0%BC%E4%B8%8E%E7%BE%8E%E5%85%83%E6%B1%87%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB/">一文读懂黄金价格与美元汇率的关系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p>长期以来，由于黄金价格有美元计价，直接受到美元价格的影响，因此黄金与美元呈现负相关性</p>
<h2 id="黄金与美元关系"><a href="#黄金与美元关系" class="headerlink" title="黄金与美元关系"></a>黄金与美元关系</h2><p>黄金金价为什么与美元有关？</p>
<p>黄金价格与美元的关系主要有以下两个方面：</p>
<p>黄金的定价货币是美元：黄金是国际商品之一，其价格是以美元计价的。这意味着全球黄金交易的价格都以美元为基准。<br>因此，当美元汇率走强时，即美元升值时，其他货币购买美元所需的成本会增加，因此购买黄金的成本也会增加，抑制了持有其他货币的投资者的消费，导致黄金价格走低。<br>相反，当美元汇率走弱时，即美元贬值时，其他货币购买美元所需的成本会降低，因此购买黄金的成本也会降低，从而刺激需求，导致黄金需求量增加，反映在黄金价格上表现为上涨。</p>
<p>美元与黄金之间存在避险关系：黄金被视为一种避险资产，可以用来对冲经济不稳定、地缘政治风险等因素带来的风险。而美元也被视为一种避险货币，由于美元在全球储备货币中的地位较高，因此在避险需求增加时，投资者倾向于将资金转移至美元资产。其次，美元的升值或贬值代表着人们对美元的信心。美元升值，说明人们对美元的信心增强，从而增加对美元的持有，相对而言减少对黄金的持有，从而导致黄金价格下跌；反之，美元贬值则导致黄金价格上升。</p>
<p>因此，美元的汇率和避险需求变化都会对黄金价格产生影响</p>
<p>值得注意的是，我们所说的美元与黄金的负相关性是从长期的趋势来看的，从短期情况来看，也不排除例外情况。如前段时期便出现了美元与黄金同步上涨的局面，之所以会出现这种情况，主要是两者同为避险产品,市场避险需求的增加都有可能推动美元和黄金的同步走高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tachyongz.github.io/2025/02/19/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E9%BB%84%E9%87%91%E4%BB%B7%E6%A0%BC%E4%B8%8E%E7%BE%8E%E5%85%83%E6%B1%87%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB/" data-id="cm7bdgfep00004ov3dsli0vzf" data-title="一文读懂黄金价格与美元汇率的关系" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/">软件配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Steam/" rel="tag">Steam</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Steam/" style="font-size: 10px;">Steam</a> <a href="/tags/vscode/" style="font-size: 10px;">vscode</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/06/%E5%A6%82%E4%BD%95%E5%9C%A8steam%E4%B8%8A%E5%85%A5%E5%BA%93%E9%94%81%E5%9B%BD%E5%8C%BA%E7%9A%84%E6%B8%B8%E6%88%8F/">如何在steam上入库锁国区的游戏</a>
          </li>
        
          <li>
            <a href="/2025/05/10/%E6%9B%B4%E6%94%B9VSCode%E6%8F%92%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/">更改VSCode插件的默认安装路径</a>
          </li>
        
          <li>
            <a href="/2025/03/18/%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">缓存的设计模式</a>
          </li>
        
          <li>
            <a href="/2025/03/15/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-Go-%E8%AF%AD%E8%A8%80-GMP-%E6%A8%A1%E5%9E%8B/">深入解析 Go 语言 GMP 模型</a>
          </li>
        
          <li>
            <a href="/2025/02/20/Go%E4%B8%AD%E7%9A%84context%E8%AF%A6%E8%A7%A3/">Go中的context详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>